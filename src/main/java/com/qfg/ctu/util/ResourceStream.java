package com.santaba.server.servlet.rest.utils;

import com.google.common.base.Preconditions;
import com.googlecode.cqengine.attribute.Attribute;
import com.googlecode.cqengine.query.parser.common.ParseResult;
import com.santaba.common.predicatetree.expression.FieldExprNode;
import com.santaba.common.predicatetree.predicate.GTPredicate;
import com.santaba.common.predicatetree.predicate.LTPredicate;
import com.santaba.common.predicatetree.predicate.SpecialPredicate;
import com.santaba.common.util.Pair;
import com.santaba.server.dal.ApiCommParamsParser;
import com.santaba.server.servlet.rest.base.pojos.Pagination;
import com.santaba.server.servlet.rest.base.resources.ResourceBase;
import org.apache.commons.collections.CollectionUtils;

import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.googlecode.cqengine.query.QueryFactory.noQueryOptions;
import static com.googlecode.cqengine.stream.StreamFactory.streamOf;
import static com.santaba.server.util.LMUtils.toCollection;

/**
 * A sequence of elements supporting sequential and parallel aggregate
 * operations.  The following example illustrates an aggregate operation using
 * {@link ResourceStream}:
 *
 * <pre>{@code
 *     Pagination<RestWidget> result = ResourceStream.of(Widget.class, Stream.of(widgets), commParams)
 *                      .stage((restWidget, widget) -> restWidget.id == widget.getId)
 *                      .filterOuter(restWidget -> RBAC.canRead(restWidget.id))
 *                      .paging();
 * }</pre>
 *
 * In this example, {@code widgets} is a {@code Collection<Widget>}.  We create
 * a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()},
 * stage it to outer class RestWidget,
 * filter it to produce a stream containing only the readable widgets, and then
 * transform it into a pagination representing the result matched by {@link ResourceBase.ApiCommParams}.
 *
 * @author Created by Robert Qin on 22/01/2018.
 */
public class ResourceStream<D, R> {
    public final static Predicate<String> ALL = f -> true;
    public final static Predicate<String> NONE = f -> false;

    private final Class<D> _outerClz;
    private final ResourceBase.ApiCommParams _commParams;
    private final Set<Pair<Predicate<String>, BiFunction<? super D, ? super R, ? extends D>>> _delayedStage = new HashSet<>();
    private final Set<String> _filterFields;
    private Stream<Pair<D, R>> _stream;
    private final Set<String> _sorted = new HashSet<>();
    private final Set<String> _readyForFilterFields = new HashSet<>();
    private final Set<String> _filteredFields = new HashSet<>();

    private ResourceStream(Class<D> outerClz, Stream<R> innerResource, ResourceBase.ApiCommParams commParams) {
        this._outerClz = outerClz;
        this._stream = innerResource.map(n -> new Pair<>(null, n));
        this._commParams = commParams;
        this._filterFields = commParams.getFilterFileds();
    }

    /**
     * Returns a sequential ordered stream whose elements are generated by the specified {@code innerResource} stream.
     *
     * @param <R> the type of resource stream elements
     * @param outerClz the class of finally output resource
     * @param innerResource the resource stream
     * @param commParams treat this stream by parameters in {@link ResourceBase.ApiCommParams}, such as filter, sort and paging
     * @return the new stream
     */
    public static <D, R> ResourceStream<D, R> of(Class<D> outerClz, Stream<R> innerResource, ResourceBase.ApiCommParams commParams) throws IllegalAccessException, InstantiationException {
        return new ResourceStream<>(outerClz, innerResource, commParams);
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream or do nothing if all fields
     * referred by {@link ResourceBase.ApiCommParams} not included in {@code included}.
     *
     * <P>It may be evaluated lazily if it is not include in {@link ResourceBase.ApiCommParams#filter},
     * It will not be evaluated if all filed evaluated at this stage are useless for {@link ResourceBase.ApiCommParams}.</P>
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param included which fields included at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> stage(Collection<String> included, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return stage(_getIncludedPredicate(included), mapper);
    }

    public ResourceStream<D, R> stage(String included, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return stage(Collections.singletonList(included), mapper);
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream or do nothing if all fields
     * referred by {@link ResourceBase.ApiCommParams} included in {@code excluded}.
     *
     *<P>It may be evaluated lazily if it is not include in {@link ResourceBase.ApiCommParams#filter},
     * It will not be evaluated if all filed evaluated at this stage are useless for {@link ResourceBase.ApiCommParams}.</P>
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param excluded which fields excluded at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> stageExcept(Collection<String> excluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        Predicate<String> predicate = _getIncludedPredicate(excluded);
        return stage(f -> !predicate.test(f), mapper);
    }

    public ResourceStream<D, R> stageExcept(String excluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return stage(Collections.singletonList(excluded), mapper);
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream or do nothing if all fields
     * referred by {@link ResourceBase.ApiCommParams} not pass {@code isIncluded} test.
     *
     * <P>It may be evaluated lazily if it is not include in {@link ResourceBase.ApiCommParams#filter},
     * It will not be evaluated if all filed evaluated at this stage are useless for {@link ResourceBase.ApiCommParams}.</P>
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param isIncluded used to test which fields included at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> stage(Predicate<String> isIncluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        Preconditions.checkNotNull(isIncluded);
        Preconditions.checkNotNull(mapper);

        // Delay the stage as later as possible if its fields not cared by filter.
        if (_isFilterCared(isIncluded)) {
            _applyFilterableStage(isIncluded, mapper);
            _filterReadyFields();
        }
        else {
            _delayedStage.add(new Pair<>(isIncluded, mapper));
        }

        return this;
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream.
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param included which fields included at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> baseStage(Collection<String> included, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return baseStage(_getIncludedPredicate(included), mapper);
    }

    public ResourceStream<D, R> baseStage(String included, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return baseStage(Collections.singletonList(included), mapper);
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream.
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param excluded which fields excluded at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> baseStageExcept(Collection<String> excluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        Predicate<String> predicate = _getIncludedPredicate(excluded);
        return baseStage(f -> !predicate.test(f), mapper);
    }

    public ResourceStream<D, R> baseStageExcept(String excluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return baseStage(Collections.singletonList(excluded), mapper);
    }

    /**
     * Returns a stream consisting of the results of applying the given
     * function to the elements of this stream.
     *
     * <p>This is an intermediate operation</p>.
     *
     * @param isIncluded used to test which fields included at this stage
     * @param mapper a non-interfering, stateless
     *               function to apply to each element
     * @return the new stream
     */
    public ResourceStream<D, R> baseStage(Predicate<String> isIncluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        Preconditions.checkNotNull(isIncluded);
        Preconditions.checkNotNull(mapper);

        _applyFilterableStage(isIncluded, mapper);
        if (_isFilterCared(isIncluded)) {
            _filterReadyFields();
        }

        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream that match
     * the given predicate.
     *
     * <p>This is an intermediate operation</a>.
     *
     * @param predicate a non-interfering, stateless
     *                  predicate to apply to each element to determine if it
     *                  should be included
     * @return the new stream
     */
    public ResourceStream<D, R> filter(Predicate<D> predicate) {
        _stream = _stream.filter(pair -> predicate.test(pair.getFirst()));
        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream, sorted
     * according to the provided {@link ResourceBase.ApiCommParams}.
     *
     * <p>For ordered streams, the sort is stable. For unordered streams, no
     * stability guarantees are made.
     *
     * <p>This is a stateful intermediate operation</p>.
     *
     * @return the new stream
     */
    public ResourceStream<D, R> sorted() {
        List<ResourceBase.SortField> leftFields = _commParams.sortList.stream()
                .filter(f -> !_sorted.contains(f.fieldName))
                .collect(Collectors.toList());

        if (CollectionUtils.isNotEmpty(leftFields)) {
            // Apply the stages delayed if just cared by sort list.
            Set<String> fieldNames = leftFields.stream().map(s -> s.fieldName).collect(Collectors.toSet());
            _stream = _applyDelayedStages(_stream, fieldNames);

            GTPredicate gt = new GTPredicate<>();
            LTPredicate lt = new LTPredicate<>();
            _stream = _stream.sorted((t1, t2) -> {
                for (ResourceBase.SortField s : leftFields) {
                    Attribute<D, ?> f = AttributeUtil.get(_outerClz, s.fieldName);
                    if (Objects.isNull(f)) {
                        continue;
                    }

                    List<?> values1 = streamOf(f.getValues(t1.getFirst(), noQueryOptions())).collect(Collectors.toList());
                    List<?> values2 = streamOf(f.getValues(t2.getFirst(), noQueryOptions())).collect(Collectors.toList());

                    // size() < 1 means the value is null.
                    if (values1.size() < 1) {
                        if (values2.size() == 1) {
                            return s.descSort ? 1 : -1;
                        }
                        continue;
                    }
                    else if (values2.size() < 1) {
                        if (values1.size() == 1) {
                            return s.descSort ? -1 : 1;
                        }
                        continue;
                    }
                    else if (values1.size() != 1 || values2.size() != 1) {
                        continue;
                    }

                    if (!Comparable.class.isAssignableFrom(values1.get(0).getClass())) {
                        continue;
                    }

                    Comparable<?> v1 = (Comparable<?>)values1.get(0);
                    Comparable<?> v2 = (Comparable<?>)values2.get(0);
                    if (gt.test(v1, v2)) {
                        return s.descSort ? -1 : 1;
                    }
                    else if (lt.test(v1, v2)) {
                        return s.descSort ? 1 : -1;
                    }
                }

                return 0;
            });

            _sorted.addAll(fieldNames);
        }

        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream, sorted
     * according to the provided {@code Comparator}.
     *
     * <p>For ordered streams, the sort is stable. For unordered streams, no
     * stability guarantees are made.
     *
     * <p>This is a stateful intermediate operation</p>.
     *
     * @param comparator a non-interfering, stateless
     *                   {@code Comparator} to be used to compare stream elements
     * @return the new stream
     */
    public ResourceStream<D, R> sorted(Comparator<? super D> comparator) {
        _stream = _applyDelayedStages(_stream, _commParams.fieldsSet);
        _stream = _stream.sorted((o1, o2) -> comparator.compare(o1.getFirst(), o2.getFirst()));
        _sorted.addAll(
                _commParams.sortList.stream()
                .map(f -> f.fieldName)
                .collect(Collectors.toList()));

        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream, sorted
     * according to the provided field and {@code Comparator}.
     *
     * <p>For ordered streams, the sort is stable. For unordered streams, no
     * stability guarantees are made.
     *
     * <p>This is a stateful intermediate operation</p>.
     *
     * @param field fieldName to be used to sort elements
     * @param comparator a non-interfering, stateless
     *                   {@code Comparator} to be used to compare stream elements
     * @return the new stream
     */
    public <A> ResourceStream<D, R> sorted(String field, Comparator<A> comparator) {
        FieldExprNode<D, ? extends A> f;
        try {
            f = FieldExprNode.of(this._outerClz, field);
        }
        catch (NoSuchFieldException e) {
            throw new IllegalArgumentException("No such field");
        }

        _stream = _applyDelayedStages(_stream, Collections.singletonList(field));
        _stream = _stream.sorted((o1, o2) -> comparator.compare(f.calculate(o1.getFirst()), f.calculate(o2.getFirst())));

        _sorted.add(field);

        return this;
    }

    /**
     * Returns a stream consisting of the distinct elements (according to
     * {@link Object#equals(Object)} if {@link ResourceBase.ApiCommParams#fieldsSet} is empty,
     * or apply equals to each object in the fields) of this stream.
     *
     * <p>For ordered streams, the selection of distinct elements is stable
     * (for duplicated elements, the element appearing first in the encounter
     * order is preserved.)  For unordered streams, no stability guarantees
     * are made.
     *
     * <p>This is a stateful intermediate operation</p>.
     *
     *
     * @return the new stream
     */
    public ResourceStream<D, R> distinct() {
        if (_commParams.needDistinctValue()) {
            // Apply delayed stages included in fieldsSet.
            _stream = _applyDelayedStages(_stream, _commParams.fieldsSet);
            Collection<Attribute<D, ?>> fields = DistinctWrap.of(_outerClz, _commParams);
            Stream<DistinctWrap<D, R>> distinctWrap =
                    _stream.map(o -> new DistinctWrap<>(fields, o.getFirst(), o.getSecond()));
            distinctWrap = distinctWrap.distinct();
            _stream = distinctWrap.map(o -> new Pair<>(o.getObj(), o.getSource()));

        }

        return this;
    }


    /**
     * Returns a stream consisting of the elements of this stream, additionally
     * performing the provided action on each element as elements are consumed
     * from the resulting stream.
     *
     * <p>This is a short-circuiting stateful intermediate operation.</p>
     *
     * @apiNote This method exists mainly to support debugging, where you want
     * to see the elements as they flow past a certain point in a pipeline:
     * <pre>{@code
     *     Stream.of(...)
     *         .peek(e -> System.out.println("value: " + e))
     *         .collect(Collectors.toList());
     * }</pre>
     *
     * @param action a non-interfering action to perform on the elements as
     *                 they are consumed from the stream
     * @return the new stream
     */
    public ResourceStream<D, R> peek(Consumer<? super D> action) {
        _stream = _stream.peek(pair -> action.accept(pair.getFirst()));
        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream, truncated
     * to be no longer than {@code maxSize} in length.
     *
     * <p>This is a short-circuiting stateful intermediate operation.</p>
     *
     * @param maxSize the number of elements the stream should be limited to
     * @return the new stream
     * @throws IllegalArgumentException if {@code maxSize} is negative
     */
    public ResourceStream<D, R> limit(long maxSize) {
        _stream = _stream.limit(maxSize);
        return this;
    }

    /**
     * Returns a stream consisting of the remaining elements of this stream
     * after discarding the first {@code n} elements of the stream.
     * If this stream contains fewer than {@code n} elements then an
     * empty stream will be returned.
     *
     * <p>This is a short-circuiting stateful intermediate operation.</p>
     *
     * @param n the number of leading elements to skip
     * @return the new stream
     * @throws IllegalArgumentException if {@code n} is negative
     */
    public ResourceStream<D, R> skip(long n) {
        _stream = _stream.skip(n);
        return this;
    }

    /**
     * Returns a stream consisting of the results of outer elements of this stream without applying
     * any functions of {@link ResourceBase.ApiCommParams} except filter and extra filter.
     *
     * <p>This is a short-circuiting stateful intermediate operation.</p>
     *
     * @return the new stream
     */
    public Stream<D> mapToResource() {
        return  _applyDelayedStages(_stream, _commParams.fieldsSet).map(Pair::getFirst);
    }

    /**
     * Returns a {@link Pagination} of the results of elements of this stream with applying
     * {@link ResourceBase.ApiCommParams}.
     *
     <p>This is a terminal operation</p>.
     *
     * @return the {@link Pagination}
     */
    public Pagination<D> paged() {
        sorted();
        List<Pair<D, R>> matched = distinct()._stream.collect(Collectors.toList());
        Pagination<D> pagination = new Pagination<>();
        pagination.total = matched.size();
        pagination.items.addAll(
                // Apply delayed stages if included in fieldsSet after paged.
                _applyDelayedStages(
                    _paging(matched, _commParams.size, _commParams.offset).stream(), _commParams.fieldsSet
                )
                .map(Pair::getFirst)
                .collect(Collectors.toList()));

        return pagination;
    }

    /**
     * Get the paged data from the collection
     *
     * @param values list that contains the whole data
     * @param size   max size of returned list, if size=-1, return all records
     * @param offset offset of the origin list
     * @return sub set of the collection
     */
    private static <T> Collection<T> _paging(Collection<T> values, int size, int offset) {
        Objects.requireNonNull(values);

        if (size == -1) {
            return values;
        }

        offset = Math.max(0, offset);
        size = Math.max(0, size);
        return values.stream().skip(offset).limit(size).collect(Collectors.toList());
    }

    private Stream<Pair<D, R>> _applyDelayedStages(Stream<Pair<D, R>> stream, Collection<String> fields) {
        Iterator<Pair<Predicate<String>, BiFunction<? super D, ? super R, ? extends D>>> it = _delayedStage.iterator();
        while (it.hasNext()) {
            Pair<Predicate<String>, BiFunction<? super D, ? super R, ? extends D>> pair = it.next();
            // empty fields means all fields included.
            if (CollectionUtils.isEmpty(fields) || fields.stream().anyMatch(pair.getFirst())) {
                stream = _applyStage(stream, pair.getSecond());
                it.remove(); // remove stage if applied.
            }
        }

        return stream;
    }

    private void _applyFilterableStage(Predicate<String> isIncluded, BiFunction<? super D, ? super R, ? extends D> mapper) {
        _readyForFilterFields.addAll(_filterFields.stream().filter(isIncluded).collect(Collectors.toSet()));
        _stream = _applyStage(_stream, mapper);
    }

    private Stream<Pair<D, R>> _applyStage(Stream<Pair<D, R>> stream, BiFunction<? super D, ? super R, ? extends D> mapper) {
        return stream.map(pair -> new Pair<D, R>(mapper.apply(pair.getFirst(), pair.getSecond()), pair.getSecond()))
                     .filter(pair -> Objects.nonNull(pair.getFirst()));
    }

    private static Predicate<String> _getIncludedPredicate(Collection<String> included) {
        return s -> included.stream().anyMatch(n -> s.equals(n) || s.startsWith(n + "."));
    }

    private boolean _isFilterCared(Predicate<String> included) {
        return _filterFields.stream().anyMatch(included);
    }

    private void _filterReadyFields() {
        ResourceBase.ApiCommParams apiCommParams = _getCurStageParams(_commParams, _filteredFields::contains, _readyForFilterFields::contains);
        if (apiCommParams.hasFilter() || apiCommParams.hasExtraFilter()) {
            ParseResult<D> parseResult = ApiCommParamsParser.forPojoWithAttributesSupplier(_outerClz, name -> AttributeUtil.get(_outerClz, name))
                    .parse(apiCommParams);
            _stream = _stream.filter(pair -> parseResult.getQuery().matches(pair.getFirst(), parseResult.getQueryOptions()));
            _filteredFields.addAll(apiCommParams.getFilterFileds());
        }
    }

    public static SpecialPredicate.SpecialValue transSpecial(String value) {
        return "empty".equalsIgnoreCase(value) ? new SpecialPredicate.Empty() : new SpecialPredicate.Null();
    }

    private static ResourceBase.ApiCommParams _getCurStageParams(ResourceBase.ApiCommParams params,
                                                                 Predicate<String> preStageIncluded,
                                                                 Predicate<String> curStageIncluded) {
        ResourceBase.ApiCommParams apiCommParams = new ResourceBase.ApiCommParams();
        if (params.hasFilter()) {
            ResourceBase.Filter filter = _getReadyFilter(params.filter, preStageIncluded, curStageIncluded);
            if (CollectionUtils.isNotEmpty(filter.filters)) {
                apiCommParams.filter = filter;
            }
        }

        if (params.hasExtraFilter()) {
            if (ResourceBase.Filter.LOGIC_AND.equalsIgnoreCase(params.extraFilter.relation)) {
                // use the ready ones for and
                List<ResourceBase.Filter> filters = params.extraFilter.filters
                        .stream()
                        .map(f -> _getReadyFilter(f, preStageIncluded, curStageIncluded))
                        .filter(f -> CollectionUtils.isNotEmpty(f.filters))
                        .collect(Collectors.toList());
                if (CollectionUtils.isNotEmpty(filters)) {
                    apiCommParams.extraFilter = new ResourceBase.ExtraFilter(filters, params.extraFilter.relation);
                }
            }
            else {
                // should all be ready
                List<ResourceBase.Filter> filters = params.extraFilter.filters
                        .stream()
                        .map(f -> _getReadyFilter(f, preStageIncluded, curStageIncluded))
                        .collect(Collectors.toList());
                if (filters.stream().allMatch(f -> CollectionUtils.isNotEmpty(f.filters))) {
                    apiCommParams.extraFilter = new ResourceBase.ExtraFilter(filters, params.extraFilter.relation);
                }
            }
        }

        return apiCommParams;
    }

    private static ResourceBase.Filter _getReadyFilter(ResourceBase.Filter filter,
                                                       Predicate<String> preStageIncluded,
                                                       Predicate<String> curStageIncluded) {
        if (ResourceBase.Filter.LOGIC_AND.equalsIgnoreCase(filter.relation)) {
            return _getReadyForAndFilter(filter, preStageIncluded, curStageIncluded);
        }
        else {
            return _getReadyForOrFilter(filter, preStageIncluded, curStageIncluded);
        }
    }

    private static ResourceBase.Filter _getReadyForAndFilter(ResourceBase.Filter filter,
                                                       Predicate<String> preStageIncluded,
                                                       Predicate<String> curStageIncluded) {
        List<FieldFilter> fieldFilters = filter.filters
                .stream()
                .filter(f -> !preStageIncluded.test(f.getFieldName()))
                .filter(f -> curStageIncluded.test(f.getFieldName()))
                .collect(Collectors.toList());
        return new ResourceBase.Filter(fieldFilters, filter.relation);
    }

    private static ResourceBase.Filter _getReadyForOrFilter(ResourceBase.Filter filter,
                                                             Predicate<String> preStageIncluded,
                                                             Predicate<String> curStageIncluded) {
        if (filter.filters.stream().allMatch(f -> preStageIncluded.test(f.getFieldName()))) {
            return new ResourceBase.Filter(Collections.emptyList(), filter.relation);
        }
        else if (filter.filters.stream().allMatch(f -> curStageIncluded.test(f.getFieldName()))) {
            return filter;
        }
        else {
            return new ResourceBase.Filter(Collections.emptyList(), filter.relation);
        }
    }

    private static class DistinctWrap<T, S> {
        final Collection<Attribute<T, ?>> _fields;
        final T _obj;
        final S _source;

        DistinctWrap(Collection<Attribute<T, ?>> fields, T obj, S source) {
            this._fields = fields;
            this._obj = obj;
            this._source = source;
        }

        T getObj() {
            return _obj;
        }
        S getSource() {
            return _source;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            DistinctWrap<T, S> that = (DistinctWrap<T, S>) o;

            if (Objects.isNull(_obj)) {
                return Objects.isNull(that._obj);
            }
            else if (Objects.isNull(that._obj)) {
                return false;
            }

            if (CollectionUtils.isEmpty(_fields)) {
                return _obj.equals(that._obj);
            }

            return _fields.stream().allMatch(f -> CollectionUtils.isEqualCollection(toCollection(f.getValues(_obj, noQueryOptions())), toCollection(f.getValues(that._obj,noQueryOptions()))));
        }

        @Override
        public int hashCode() {
            if (Objects.isNull(_obj)) {
                return 0;
            }

            if (CollectionUtils.isEmpty(_fields)) {
                return _obj.hashCode();
            }

            return _fields.stream().mapToInt(f -> toCollection(f.getValues(_obj, noQueryOptions())).hashCode()).sum();
        }

        static <T> Collection<Attribute<T, ?>> of(Class<T> clz, ResourceBase.ApiCommParams commParams) {
            return commParams.fieldsSet
                    .stream()
                    .map(field -> (Attribute<T, ?>)AttributeUtil.get(clz, field))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
        }
    }
}
